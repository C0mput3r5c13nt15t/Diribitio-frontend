{"version":3,"sources":["webpack:///node_modules/@ionic/core/dist/esm/ion-reorder_2.entry.js"],"names":["Reorder","hostRef","this","ev","preventDefault","stopImmediatePropagation","mode","reorderIcon","class","name","lazy","part","style","ios","md","ReorderGroup","ionItemReorder","lastToIndex","cachedHeights","scrollElTop","scrollElBottom","scrollElInitial","containerTop","containerBottom","state","disabled","gesture","enable","contentEl","el","closest","scrollEl","getScrollElement","createGesture","gestureName","gesturePriority","threshold","direction","passive","canStart","detail","onStart","onMove","onEnd","disabledChanged","destroy","undefined","listOrReorder","Promise","resolve","completeSync","selectedItemEl","reorderEl","event","target","item","findReorderItem","data","heights","length","children","sum","i","child","offsetHeight","push","$ionIndex","box","getBoundingClientRect","top","bottom","scrollBox","scrollTop","AUTO_SCROLL_MARGIN","indexForItem","selectedItemHeight","classList","add","ITEM_REORDER_SELECTED","selectedItem","scroll","autoscroll","currentY","Math","max","min","deltaY","startY","toIndex","itemIndexForTop","fromIndex","reorderMove","transform","emit","from","to","complete","bind","len","insertBefore","Array","isArray","reorderArray","transition","remove","itemHeight","value","posY","amount","SCROLL_JUMP","scrollBy","element","node","container","parent","parentElement","array","splice","slice"],"mappings":"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","file":"x","sourcesContent":["import { r as registerInstance, h, H as Host, e as createEvent, i as getElement } from './index-92848855.js';\nimport { b as getIonMode } from './ionic-global-23e7365a.js';\nimport { a as hapticSelectionStart, b as hapticSelectionChanged, h as hapticSelectionEnd } from './haptic-7b8ba70a.js';\n\nconst reorderIosCss = \":host([slot]){display:none;line-height:0;z-index:100}.reorder-icon{display:block;font-size:22px}.reorder-icon{font-size:34px;opacity:0.4}\";\n\nconst reorderMdCss = \":host([slot]){display:none;line-height:0;z-index:100}.reorder-icon{display:block;font-size:22px}.reorder-icon{font-size:31px;opacity:0.3}\";\n\nconst Reorder = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n    }\n    onClick(ev) {\n        ev.preventDefault();\n        ev.stopImmediatePropagation();\n    }\n    render() {\n        const mode = getIonMode(this);\n        const reorderIcon = mode === 'ios' ? 'reorder-three-outline' : 'reorder-two-sharp';\n        return (h(Host, { class: mode }, h(\"slot\", null, h(\"ion-icon\", { name: reorderIcon, lazy: false, class: \"reorder-icon\", part: \"icon\" }))));\n    }\n};\nReorder.style = {\n    ios: reorderIosCss,\n    md: reorderMdCss\n};\n\nconst reorderGroupCss = \".reorder-list-active>*{-webkit-transition:-webkit-transform 300ms;transition:-webkit-transform 300ms;transition:transform 300ms;transition:transform 300ms, -webkit-transform 300ms;will-change:transform}.reorder-enabled{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.reorder-enabled ion-reorder{display:block;cursor:-webkit-grab;cursor:grab;pointer-events:all;-ms-touch-action:none;touch-action:none}.reorder-selected,.reorder-selected ion-reorder{cursor:-webkit-grabbing;cursor:grabbing}.reorder-selected{position:relative;-webkit-transition:none !important;transition:none !important;-webkit-box-shadow:0 0 10px rgba(0, 0, 0, 0.4);box-shadow:0 0 10px rgba(0, 0, 0, 0.4);opacity:0.8;z-index:100}.reorder-visible ion-reorder .reorder-icon{-webkit-transform:translate3d(0,  0,  0);transform:translate3d(0,  0,  0)}\";\n\nconst ReorderGroup = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n        this.ionItemReorder = createEvent(this, \"ionItemReorder\", 7);\n        this.lastToIndex = -1;\n        this.cachedHeights = [];\n        this.scrollElTop = 0;\n        this.scrollElBottom = 0;\n        this.scrollElInitial = 0;\n        this.containerTop = 0;\n        this.containerBottom = 0;\n        this.state = 0 /* Idle */;\n        /**\n         * If `true`, the reorder will be hidden.\n         */\n        this.disabled = true;\n    }\n    disabledChanged() {\n        if (this.gesture) {\n            this.gesture.enable(!this.disabled);\n        }\n    }\n    async connectedCallback() {\n        const contentEl = this.el.closest('ion-content');\n        if (contentEl) {\n            this.scrollEl = await contentEl.getScrollElement();\n        }\n        this.gesture = (await import('./index-eea61379.js')).createGesture({\n            el: this.el,\n            gestureName: 'reorder',\n            gesturePriority: 110,\n            threshold: 0,\n            direction: 'y',\n            passive: false,\n            canStart: detail => this.canStart(detail),\n            onStart: ev => this.onStart(ev),\n            onMove: ev => this.onMove(ev),\n            onEnd: () => this.onEnd(),\n        });\n        this.disabledChanged();\n    }\n    disconnectedCallback() {\n        this.onEnd();\n        if (this.gesture) {\n            this.gesture.destroy();\n            this.gesture = undefined;\n        }\n    }\n    /**\n     * Completes the reorder operation. Must be called by the `ionItemReorder` event.\n     *\n     * If a list of items is passed, the list will be reordered and returned in the\n     * proper order.\n     *\n     * If no parameters are passed or if `true` is passed in, the reorder will complete\n     * and the item will remain in the position it was dragged to. If `false` is passed,\n     * the reorder will complete and the item will bounce back to its original position.\n     *\n     * @param listOrReorder A list of items to be sorted and returned in the new order or a\n     * boolean of whether or not the reorder should reposition the item.\n     */\n    complete(listOrReorder) {\n        return Promise.resolve(this.completeSync(listOrReorder));\n    }\n    canStart(ev) {\n        if (this.selectedItemEl || this.state !== 0 /* Idle */) {\n            return false;\n        }\n        const target = ev.event.target;\n        const reorderEl = target.closest('ion-reorder');\n        if (!reorderEl) {\n            return false;\n        }\n        const item = findReorderItem(reorderEl, this.el);\n        if (!item) {\n            return false;\n        }\n        ev.data = item;\n        return true;\n    }\n    onStart(ev) {\n        ev.event.preventDefault();\n        const item = this.selectedItemEl = ev.data;\n        const heights = this.cachedHeights;\n        heights.length = 0;\n        const el = this.el;\n        const children = el.children;\n        if (!children || children.length === 0) {\n            return;\n        }\n        let sum = 0;\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            sum += child.offsetHeight;\n            heights.push(sum);\n            child.$ionIndex = i;\n        }\n        const box = el.getBoundingClientRect();\n        this.containerTop = box.top;\n        this.containerBottom = box.bottom;\n        if (this.scrollEl) {\n            const scrollBox = this.scrollEl.getBoundingClientRect();\n            this.scrollElInitial = this.scrollEl.scrollTop;\n            this.scrollElTop = scrollBox.top + AUTO_SCROLL_MARGIN;\n            this.scrollElBottom = scrollBox.bottom - AUTO_SCROLL_MARGIN;\n        }\n        else {\n            this.scrollElInitial = 0;\n            this.scrollElTop = 0;\n            this.scrollElBottom = 0;\n        }\n        this.lastToIndex = indexForItem(item);\n        this.selectedItemHeight = item.offsetHeight;\n        this.state = 1 /* Active */;\n        item.classList.add(ITEM_REORDER_SELECTED);\n        hapticSelectionStart();\n    }\n    onMove(ev) {\n        const selectedItem = this.selectedItemEl;\n        if (!selectedItem) {\n            return;\n        }\n        // Scroll if we reach the scroll margins\n        const scroll = this.autoscroll(ev.currentY);\n        // // Get coordinate\n        const top = this.containerTop - scroll;\n        const bottom = this.containerBottom - scroll;\n        const currentY = Math.max(top, Math.min(ev.currentY, bottom));\n        const deltaY = scroll + currentY - ev.startY;\n        const normalizedY = currentY - top;\n        const toIndex = this.itemIndexForTop(normalizedY);\n        if (toIndex !== this.lastToIndex) {\n            const fromIndex = indexForItem(selectedItem);\n            this.lastToIndex = toIndex;\n            hapticSelectionChanged();\n            this.reorderMove(fromIndex, toIndex);\n        }\n        // Update selected item position\n        selectedItem.style.transform = `translateY(${deltaY}px)`;\n    }\n    onEnd() {\n        const selectedItemEl = this.selectedItemEl;\n        this.state = 2 /* Complete */;\n        if (!selectedItemEl) {\n            this.state = 0 /* Idle */;\n            return;\n        }\n        const toIndex = this.lastToIndex;\n        const fromIndex = indexForItem(selectedItemEl);\n        if (toIndex === fromIndex) {\n            this.completeSync();\n        }\n        else {\n            this.ionItemReorder.emit({\n                from: fromIndex,\n                to: toIndex,\n                complete: this.completeSync.bind(this)\n            });\n        }\n        hapticSelectionEnd();\n    }\n    completeSync(listOrReorder) {\n        const selectedItemEl = this.selectedItemEl;\n        if (selectedItemEl && this.state === 2 /* Complete */) {\n            const children = this.el.children;\n            const len = children.length;\n            const toIndex = this.lastToIndex;\n            const fromIndex = indexForItem(selectedItemEl);\n            if (toIndex !== fromIndex && (listOrReorder === undefined || listOrReorder === true)) {\n                const ref = (fromIndex < toIndex)\n                    ? children[toIndex + 1]\n                    : children[toIndex];\n                this.el.insertBefore(selectedItemEl, ref);\n            }\n            if (Array.isArray(listOrReorder)) {\n                listOrReorder = reorderArray(listOrReorder, fromIndex, toIndex);\n            }\n            for (let i = 0; i < len; i++) {\n                children[i].style['transform'] = '';\n            }\n            selectedItemEl.style.transition = '';\n            selectedItemEl.classList.remove(ITEM_REORDER_SELECTED);\n            this.selectedItemEl = undefined;\n            this.state = 0 /* Idle */;\n        }\n        return listOrReorder;\n    }\n    itemIndexForTop(deltaY) {\n        const heights = this.cachedHeights;\n        let i = 0;\n        // TODO: since heights is a sorted array of integers, we can do\n        // speed up the search using binary search. Remember that linear-search is still\n        // faster than binary-search for small arrays (<64) due CPU branch misprediction.\n        for (i = 0; i < heights.length; i++) {\n            if (heights[i] > deltaY) {\n                break;\n            }\n        }\n        return i;\n    }\n    /********* DOM WRITE ********* */\n    reorderMove(fromIndex, toIndex) {\n        const itemHeight = this.selectedItemHeight;\n        const children = this.el.children;\n        for (let i = 0; i < children.length; i++) {\n            const style = children[i].style;\n            let value = '';\n            if (i > fromIndex && i <= toIndex) {\n                value = `translateY(${-itemHeight}px)`;\n            }\n            else if (i < fromIndex && i >= toIndex) {\n                value = `translateY(${itemHeight}px)`;\n            }\n            style['transform'] = value;\n        }\n    }\n    autoscroll(posY) {\n        if (!this.scrollEl) {\n            return 0;\n        }\n        let amount = 0;\n        if (posY < this.scrollElTop) {\n            amount = -SCROLL_JUMP;\n        }\n        else if (posY > this.scrollElBottom) {\n            amount = SCROLL_JUMP;\n        }\n        if (amount !== 0) {\n            this.scrollEl.scrollBy(0, amount);\n        }\n        return this.scrollEl.scrollTop - this.scrollElInitial;\n    }\n    render() {\n        const mode = getIonMode(this);\n        return (h(Host, { class: {\n                [mode]: true,\n                'reorder-enabled': !this.disabled,\n                'reorder-list-active': this.state !== 0 /* Idle */,\n            } }));\n    }\n    get el() { return getElement(this); }\n    static get watchers() { return {\n        \"disabled\": [\"disabledChanged\"]\n    }; }\n};\nconst indexForItem = (element) => {\n    return element['$ionIndex'];\n};\nconst findReorderItem = (node, container) => {\n    let parent;\n    while (node) {\n        parent = node.parentElement;\n        if (parent === container) {\n            return node;\n        }\n        node = parent;\n    }\n    return undefined;\n};\nconst AUTO_SCROLL_MARGIN = 60;\nconst SCROLL_JUMP = 10;\nconst ITEM_REORDER_SELECTED = 'reorder-selected';\nconst reorderArray = (array, from, to) => {\n    const element = array[from];\n    array.splice(from, 1);\n    array.splice(to, 0, element);\n    return array.slice();\n};\nReorderGroup.style = reorderGroupCss;\n\nexport { Reorder as ion_reorder, ReorderGroup as ion_reorder_group };\n"]}