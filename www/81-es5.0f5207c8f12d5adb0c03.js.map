{"version":3,"sources":["webpack:///node_modules/@ionic/core/dist/esm/ion-reorder_2.entry.js"],"names":["Reorder","hostRef","this","ev","preventDefault","stopImmediatePropagation","mode","reorderIcon","class","name","lazy","part","style","ios","md","ReorderGroup","ionItemReorder","lastToIndex","cachedHeights","scrollElTop","scrollElBottom","scrollElInitial","containerTop","containerBottom","state","disabled","gesture","enable","contentEl","el","closest","getScrollElement","scrollEl","createGesture","gestureName","gesturePriority","threshold","direction","passive","canStart","detail","onStart","onMove","onEnd","disabledChanged","destroy","listOrReorder","Promise","resolve","completeSync","selectedItemEl","reorderEl","event","target","item","findReorderItem","data","heights","length","children","sum","i","child","offsetHeight","push","$ionIndex","box","getBoundingClientRect","top","bottom","scrollBox","scrollTop","AUTO_SCROLL_MARGIN","indexForItem","selectedItemHeight","classList","add","ITEM_REORDER_SELECTED","selectedItem","scroll","autoscroll","currentY","Math","max","min","deltaY","startY","toIndex","itemIndexForTop","fromIndex","reorderMove","transform","emit","from","to","complete","bind","len","insertBefore","Array","isArray","reorderArray","transition","remove","itemHeight","value","posY","amount","SCROLL_JUMP","scrollBy","element","node","container","parent","parentElement","array","splice","slice"],"mappings":"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","file":"x","sourcesContent":["import { r as registerInstance, h, H as Host, e as createEvent, i as getElement } from './index-92848855.js';\nimport { b as getIonMode } from './ionic-global-23e7365a.js';\nimport { a as hapticSelectionStart, b as hapticSelectionChanged, h as hapticSelectionEnd } from './haptic-7b8ba70a.js';\n\nconst reorderIosCss = \":host([slot]){display:none;line-height:0;z-index:100}.reorder-icon{display:block;font-size:22px}.reorder-icon{font-size:34px;opacity:0.4}\";\n\nconst reorderMdCss = \":host([slot]){display:none;line-height:0;z-index:100}.reorder-icon{display:block;font-size:22px}.reorder-icon{font-size:31px;opacity:0.3}\";\n\nconst Reorder = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n    }\n    onClick(ev) {\n        ev.preventDefault();\n        ev.stopImmediatePropagation();\n    }\n    render() {\n        const mode = getIonMode(this);\n        const reorderIcon = mode === 'ios' ? 'reorder-three-outline' : 'reorder-two-sharp';\n        return (h(Host, { class: mode }, h(\"slot\", null, h(\"ion-icon\", { name: reorderIcon, lazy: false, class: \"reorder-icon\", part: \"icon\" }))));\n    }\n};\nReorder.style = {\n    ios: reorderIosCss,\n    md: reorderMdCss\n};\n\nconst reorderGroupCss = \".reorder-list-active>*{-webkit-transition:-webkit-transform 300ms;transition:-webkit-transform 300ms;transition:transform 300ms;transition:transform 300ms, -webkit-transform 300ms;will-change:transform}.reorder-enabled{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.reorder-enabled ion-reorder{display:block;cursor:-webkit-grab;cursor:grab;pointer-events:all;-ms-touch-action:none;touch-action:none}.reorder-selected,.reorder-selected ion-reorder{cursor:-webkit-grabbing;cursor:grabbing}.reorder-selected{position:relative;-webkit-transition:none !important;transition:none !important;-webkit-box-shadow:0 0 10px rgba(0, 0, 0, 0.4);box-shadow:0 0 10px rgba(0, 0, 0, 0.4);opacity:0.8;z-index:100}.reorder-visible ion-reorder .reorder-icon{-webkit-transform:translate3d(0,  0,  0);transform:translate3d(0,  0,  0)}\";\n\nconst ReorderGroup = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n        this.ionItemReorder = createEvent(this, \"ionItemReorder\", 7);\n        this.lastToIndex = -1;\n        this.cachedHeights = [];\n        this.scrollElTop = 0;\n        this.scrollElBottom = 0;\n        this.scrollElInitial = 0;\n        this.containerTop = 0;\n        this.containerBottom = 0;\n        this.state = 0 /* Idle */;\n        /**\n         * If `true`, the reorder will be hidden.\n         */\n        this.disabled = true;\n    }\n    disabledChanged() {\n        if (this.gesture) {\n            this.gesture.enable(!this.disabled);\n        }\n    }\n    async connectedCallback() {\n        const contentEl = this.el.closest('ion-content');\n        if (contentEl) {\n            this.scrollEl = await contentEl.getScrollElement();\n        }\n        this.gesture = (await import('./index-eea61379.js')).createGesture({\n            el: this.el,\n            gestureName: 'reorder',\n            gesturePriority: 110,\n            threshold: 0,\n            direction: 'y',\n            passive: false,\n            canStart: detail => this.canStart(detail),\n            onStart: ev => this.onStart(ev),\n            onMove: ev => this.onMove(ev),\n            onEnd: () => this.onEnd(),\n        });\n        this.disabledChanged();\n    }\n    disconnectedCallback() {\n        this.onEnd();\n        if (this.gesture) {\n            this.gesture.destroy();\n            this.gesture = undefined;\n        }\n    }\n    /**\n     * Completes the reorder operation. Must be called by the `ionItemReorder` event.\n     *\n     * If a list of items is passed, the list will be reordered and returned in the\n     * proper order.\n     *\n     * If no parameters are passed or if `true` is passed in, the reorder will complete\n     * and the item will remain in the position it was dragged to. If `false` is passed,\n     * the reorder will complete and the item will bounce back to its original position.\n     *\n     * @param listOrReorder A list of items to be sorted and returned in the new order or a\n     * boolean of whether or not the reorder should reposition the item.\n     */\n    complete(listOrReorder) {\n        return Promise.resolve(this.completeSync(listOrReorder));\n    }\n    canStart(ev) {\n        if (this.selectedItemEl || this.state !== 0 /* Idle */) {\n            return false;\n        }\n        const target = ev.event.target;\n        const reorderEl = target.closest('ion-reorder');\n        if (!reorderEl) {\n            return false;\n        }\n        const item = findReorderItem(reorderEl, this.el);\n        if (!item) {\n            return false;\n        }\n        ev.data = item;\n        return true;\n    }\n    onStart(ev) {\n        ev.event.preventDefault();\n        const item = this.selectedItemEl = ev.data;\n        const heights = this.cachedHeights;\n        heights.length = 0;\n        const el = this.el;\n        const children = el.children;\n        if (!children || children.length === 0) {\n            return;\n        }\n        let sum = 0;\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            sum += child.offsetHeight;\n            heights.push(sum);\n            child.$ionIndex = i;\n        }\n        const box = el.getBoundingClientRect();\n        this.containerTop = box.top;\n        this.containerBottom = box.bottom;\n        if (this.scrollEl) {\n            const scrollBox = this.scrollEl.getBoundingClientRect();\n            this.scrollElInitial = this.scrollEl.scrollTop;\n            this.scrollElTop = scrollBox.top + AUTO_SCROLL_MARGIN;\n            this.scrollElBottom = scrollBox.bottom - AUTO_SCROLL_MARGIN;\n        }\n        else {\n            this.scrollElInitial = 0;\n            this.scrollElTop = 0;\n            this.scrollElBottom = 0;\n        }\n        this.lastToIndex = indexForItem(item);\n        this.selectedItemHeight = item.offsetHeight;\n        this.state = 1 /* Active */;\n        item.classList.add(ITEM_REORDER_SELECTED);\n        hapticSelectionStart();\n    }\n    onMove(ev) {\n        const selectedItem = this.selectedItemEl;\n        if (!selectedItem) {\n            return;\n        }\n        // Scroll if we reach the scroll margins\n        const scroll = this.autoscroll(ev.currentY);\n        // // Get coordinate\n        const top = this.containerTop - scroll;\n        const bottom = this.containerBottom - scroll;\n        const currentY = Math.max(top, Math.min(ev.currentY, bottom));\n        const deltaY = scroll + currentY - ev.startY;\n        const normalizedY = currentY - top;\n        const toIndex = this.itemIndexForTop(normalizedY);\n        if (toIndex !== this.lastToIndex) {\n            const fromIndex = indexForItem(selectedItem);\n            this.lastToIndex = toIndex;\n            hapticSelectionChanged();\n            this.reorderMove(fromIndex, toIndex);\n        }\n        // Update selected item position\n        selectedItem.style.transform = `translateY(${deltaY}px)`;\n    }\n    onEnd() {\n        const selectedItemEl = this.selectedItemEl;\n        this.state = 2 /* Complete */;\n        if (!selectedItemEl) {\n            this.state = 0 /* Idle */;\n            return;\n        }\n        const toIndex = this.lastToIndex;\n        const fromIndex = indexForItem(selectedItemEl);\n        if (toIndex === fromIndex) {\n            this.completeSync();\n        }\n        else {\n            this.ionItemReorder.emit({\n                from: fromIndex,\n                to: toIndex,\n                complete: this.completeSync.bind(this)\n            });\n        }\n        hapticSelectionEnd();\n    }\n    completeSync(listOrReorder) {\n        const selectedItemEl = this.selectedItemEl;\n        if (selectedItemEl && this.state === 2 /* Complete */) {\n            const children = this.el.children;\n            const len = children.length;\n            const toIndex = this.lastToIndex;\n            const fromIndex = indexForItem(selectedItemEl);\n            if (toIndex !== fromIndex && (listOrReorder === undefined || listOrReorder === true)) {\n                const ref = (fromIndex < toIndex)\n                    ? children[toIndex + 1]\n                    : children[toIndex];\n                this.el.insertBefore(selectedItemEl, ref);\n            }\n            if (Array.isArray(listOrReorder)) {\n                listOrReorder = reorderArray(listOrReorder, fromIndex, toIndex);\n            }\n            for (let i = 0; i < len; i++) {\n                children[i].style['transform'] = '';\n            }\n            selectedItemEl.style.transition = '';\n            selectedItemEl.classList.remove(ITEM_REORDER_SELECTED);\n            this.selectedItemEl = undefined;\n            this.state = 0 /* Idle */;\n        }\n        return listOrReorder;\n    }\n    itemIndexForTop(deltaY) {\n        const heights = this.cachedHeights;\n        let i = 0;\n        // TODO: since heights is a sorted array of integers, we can do\n        // speed up the search using binary search. Remember that linear-search is still\n        // faster than binary-search for small arrays (<64) due CPU branch misprediction.\n        for (i = 0; i < heights.length; i++) {\n            if (heights[i] > deltaY) {\n                break;\n            }\n        }\n        return i;\n    }\n    /********* DOM WRITE ********* */\n    reorderMove(fromIndex, toIndex) {\n        const itemHeight = this.selectedItemHeight;\n        const children = this.el.children;\n        for (let i = 0; i < children.length; i++) {\n            const style = children[i].style;\n            let value = '';\n            if (i > fromIndex && i <= toIndex) {\n                value = `translateY(${-itemHeight}px)`;\n            }\n            else if (i < fromIndex && i >= toIndex) {\n                value = `translateY(${itemHeight}px)`;\n            }\n            style['transform'] = value;\n        }\n    }\n    autoscroll(posY) {\n        if (!this.scrollEl) {\n            return 0;\n        }\n        let amount = 0;\n        if (posY < this.scrollElTop) {\n            amount = -SCROLL_JUMP;\n        }\n        else if (posY > this.scrollElBottom) {\n            amount = SCROLL_JUMP;\n        }\n        if (amount !== 0) {\n            this.scrollEl.scrollBy(0, amount);\n        }\n        return this.scrollEl.scrollTop - this.scrollElInitial;\n    }\n    render() {\n        const mode = getIonMode(this);\n        return (h(Host, { class: {\n                [mode]: true,\n                'reorder-enabled': !this.disabled,\n                'reorder-list-active': this.state !== 0 /* Idle */,\n            } }));\n    }\n    get el() { return getElement(this); }\n    static get watchers() { return {\n        \"disabled\": [\"disabledChanged\"]\n    }; }\n};\nconst indexForItem = (element) => {\n    return element['$ionIndex'];\n};\nconst findReorderItem = (node, container) => {\n    let parent;\n    while (node) {\n        parent = node.parentElement;\n        if (parent === container) {\n            return node;\n        }\n        node = parent;\n    }\n    return undefined;\n};\nconst AUTO_SCROLL_MARGIN = 60;\nconst SCROLL_JUMP = 10;\nconst ITEM_REORDER_SELECTED = 'reorder-selected';\nconst reorderArray = (array, from, to) => {\n    const element = array[from];\n    array.splice(from, 1);\n    array.splice(to, 0, element);\n    return array.slice();\n};\nReorderGroup.style = reorderGroupCss;\n\nexport { Reorder as ion_reorder, ReorderGroup as ion_reorder_group };\n"]}